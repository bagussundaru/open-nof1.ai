import { BinanceFuturesClient } from '@/lib/exchanges/binance-futures-client';
import { NebiusAIService } from '@/lib/ai/nebius-ai-service';

// Import types and analyzer
export interface MultiTimeframeAnalysis {
  symbol: string;
  timestamp: string;
  timeframes: any;
  correlation: any;
  consensus: any;
  riskAssessment: any;
}

export interface StrategySignal {\n  symbol: string;\n  action: 'STRONG_BUY' | 'BUY' | 'HOLD' | 'SELL' | 'STRONG_SELL' | 'CLOSE_ALL';\n  confidence: number;\n  reasoning: string;\n  positionSize: number; // Recommended position size (0-1)\n  leverage: number; // Recommended leverage\n  stopLoss: number; // Stop loss price\n  takeProfit: number[]; // Multiple take profit levels\n  timeframeAlignment: number; // How well timeframes align\n  riskLevel: 'LOW' | 'MEDIUM' | 'HIGH' | 'EXTREME';\n  metadata: {\n    multiTimeframeAnalysis: MultiTimeframeAnalysis;\n    entryConditions: string[];\n    exitConditions: string[];\n    riskFactors: string[];\n  };\n}\n\nexport class MultiTimeframeStrategy {\n  private analyzer: MultiTimeframeAnalyzer;\n  private binanceClient: BinanceFuturesClient;\n  private nebiusAI: NebiusAIService;\n  \n  // Strategy configuration\n  private config = {\n    minTimeframeAlignment: 0.6, // Minimum 60% timeframe agreement\n    minConfidence: 0.7, // Minimum 70% confidence for trades\n    maxRiskPerTrade: 0.02, // Maximum 2% risk per trade\n    strongSignalThreshold: 0.8, // 80% confidence for strong signals\n    volatilityAdjustment: true, // Adjust position size based on volatility\n    trendFollowing: true, // Follow dominant trend\n    contrarian: false // Contrarian signals (disabled by default)\n  };\n  \n  constructor(binanceClient: BinanceFuturesClient, nebiusAI: NebiusAIService) {\n    this.binanceClient = binanceClient;\n    this.nebiusAI = nebiusAI;\n    this.analyzer = new MultiTimeframeAnalyzer(binanceClient, nebiusAI);\n  }\n\n  /**\n   * Generate trading signal based on multi-timeframe analysis\n   */\n  async generateSignal(symbol: string): Promise<StrategySignal> {\n    console.log(`üéØ Generating multi-timeframe strategy signal for ${symbol}...`);\n    \n    // Get multi-timeframe analysis\n    const analysis = await this.analyzer.analyzeMultiTimeframe(symbol);\n    \n    // Validate signal quality\n    const signalQuality = this.validateSignalQuality(analysis);\n    \n    if (!signalQuality.isValid) {\n      console.log(`‚ö†Ô∏è Signal quality insufficient for ${symbol}: ${signalQuality.reason}`);\n      return this.createHoldSignal(symbol, analysis, signalQuality.reason);\n    }\n    \n    // Generate strategy signal\n    const strategySignal = this.createStrategySignal(symbol, analysis);\n    \n    console.log(`‚úÖ Multi-timeframe signal generated for ${symbol}: ${strategySignal.action} (${(strategySignal.confidence * 100).toFixed(1)}% confidence)`);\n    \n    return strategySignal;\n  }\n\n  /**\n   * Validate signal quality before trading\n   */\n  private validateSignalQuality(analysis: MultiTimeframeAnalysis): { isValid: boolean; reason: string } {\n    // Check timeframe alignment\n    if (analysis.consensus.timeframeAlignment < this.config.minTimeframeAlignment) {\n      return {\n        isValid: false,\n        reason: `Low timeframe alignment: ${(analysis.consensus.timeframeAlignment * 100).toFixed(1)}% < ${(this.config.minTimeframeAlignment * 100)}%`\n      };\n    }\n    \n    // Check confidence level\n    if (analysis.consensus.confidence < this.config.minConfidence) {\n      return {\n        isValid: false,\n        reason: `Low confidence: ${(analysis.consensus.confidence * 100).toFixed(1)}% < ${(this.config.minConfidence * 100)}%`\n      };\n    }\n    \n    // Check for extreme volatility\n    if (analysis.riskAssessment.volatility === 'EXTREME') {\n      return {\n        isValid: false,\n        reason: 'Extreme market volatility detected - avoiding trades'\n      };\n    }\n    \n    // Check for high reversal probability\n    if (analysis.riskAssessment.reversalProbability > 0.8) {\n      return {\n        isValid: false,\n        reason: `High reversal probability: ${(analysis.riskAssessment.reversalProbability * 100).toFixed(1)}%`\n      };\n    }\n    \n    return { isValid: true, reason: 'Signal quality validated' };\n  }\n\n  /**\n   * Create strategy signal from analysis\n   */\n  private createStrategySignal(symbol: string, analysis: MultiTimeframeAnalysis): StrategySignal {\n    const consensus = analysis.consensus;\n    const risk = analysis.riskAssessment;\n    \n    // Determine action based on consensus and confidence\n    let action = consensus.signal;\n    \n    // Upgrade to strong signals if conditions are met\n    if (consensus.confidence >= this.config.strongSignalThreshold && \n        consensus.timeframeAlignment >= 0.8) {\n      if (consensus.signal === 'BUY') action = 'STRONG_BUY';\n      else if (consensus.signal === 'SELL') action = 'STRONG_SELL';\n    }\n    \n    // Calculate position size\n    const positionSize = this.calculatePositionSize(analysis);\n    \n    // Calculate leverage\n    const leverage = this.calculateLeverage(analysis);\n    \n    // Calculate stop loss and take profit\n    const { stopLoss, takeProfit } = this.calculateExitLevels(symbol, analysis);\n    \n    // Determine risk level\n    const riskLevel = this.determineRiskLevel(analysis);\n    \n    // Generate entry and exit conditions\n    const entryConditions = this.generateEntryConditions(analysis);\n    const exitConditions = this.generateExitConditions(analysis);\n    const riskFactors = this.identifyRiskFactors(analysis);\n    \n    return {\n      symbol,\n      action,\n      confidence: consensus.confidence,\n      reasoning: this.generateDetailedReasoning(analysis),\n      positionSize,\n      leverage,\n      stopLoss,\n      takeProfit,\n      timeframeAlignment: consensus.timeframeAlignment,\n      riskLevel,\n      metadata: {\n        multiTimeframeAnalysis: analysis,\n        entryConditions,\n        exitConditions,\n        riskFactors\n      }\n    };\n  }\n\n  /**\n   * Calculate optimal position size\n   */\n  private calculatePositionSize(analysis: MultiTimeframeAnalysis): number {\n    let baseSize = analysis.riskAssessment.recommendedPositionSize;\n    \n    // Adjust based on confidence\n    const confidenceMultiplier = Math.min(1.5, analysis.consensus.confidence * 1.5);\n    baseSize *= confidenceMultiplier;\n    \n    // Adjust based on timeframe alignment\n    const alignmentMultiplier = Math.min(1.3, analysis.consensus.timeframeAlignment * 1.3);\n    baseSize *= alignmentMultiplier;\n    \n    // Adjust based on volatility\n    switch (analysis.riskAssessment.volatility) {\n      case 'LOW':\n        baseSize *= 1.2;\n        break;\n      case 'MEDIUM':\n        baseSize *= 1.0;\n        break;\n      case 'HIGH':\n        baseSize *= 0.7;\n        break;\n      case 'EXTREME':\n        baseSize *= 0.3;\n        break;\n    }\n    \n    // Apply maximum risk limit\n    const maxSize = this.config.maxRiskPerTrade;\n    \n    return Math.max(0.005, Math.min(maxSize, baseSize)); // Min 0.5%, max configured limit\n  }\n\n  /**\n   * Calculate optimal leverage\n   */\n  private calculateLeverage(analysis: MultiTimeframeAnalysis): number {\n    let baseLeverage = 3; // Conservative base leverage\n    \n    // Adjust based on confidence and alignment\n    if (analysis.consensus.confidence >= 0.9 && analysis.consensus.timeframeAlignment >= 0.8) {\n      baseLeverage = 5; // Higher leverage for very confident signals\n    } else if (analysis.consensus.confidence >= 0.8) {\n      baseLeverage = 4;\n    }\n    \n    // Reduce leverage based on volatility\n    switch (analysis.riskAssessment.volatility) {\n      case 'LOW':\n        break; // No adjustment\n      case 'MEDIUM':\n        baseLeverage = Math.max(2, baseLeverage * 0.8);\n        break;\n      case 'HIGH':\n        baseLeverage = Math.max(2, baseLeverage * 0.6);\n        break;\n      case 'EXTREME':\n        baseLeverage = 2; // Minimum leverage\n        break;\n    }\n    \n    // Reduce leverage if reversal probability is high\n    if (analysis.riskAssessment.reversalProbability > 0.6) {\n      baseLeverage = Math.max(2, baseLeverage * 0.7);\n    }\n    \n    return Math.max(1, Math.min(10, Math.round(baseLeverage))); // 1x to 10x leverage\n  }\n\n  /**\n   * Calculate stop loss and take profit levels\n   */\n  private calculateExitLevels(symbol: string, analysis: MultiTimeframeAnalysis): { stopLoss: number; takeProfit: number[] } {\n    const currentPrice = this.getCurrentPrice(analysis);\n    const volatility = analysis.riskAssessment.volatility;\n    const isLong = ['BUY', 'STRONG_BUY'].includes(analysis.consensus.signal);\n    \n    // Calculate stop loss distance based on volatility\n    let stopLossDistance = 0.02; // 2% default\n    \n    switch (volatility) {\n      case 'LOW':\n        stopLossDistance = 0.015; // 1.5%\n        break;\n      case 'MEDIUM':\n        stopLossDistance = 0.02; // 2%\n        break;\n      case 'HIGH':\n        stopLossDistance = 0.03; // 3%\n        break;\n      case 'EXTREME':\n        stopLossDistance = 0.05; // 5%\n        break;\n    }\n    \n    // Use technical levels if available\n    const h4Data = analysis.timeframes['4h'];\n    let stopLoss: number;\n    \n    if (isLong) {\n      // For long positions, use support level or percentage-based stop\n      const supportStop = h4Data.technicalIndicators.support;\n      const percentageStop = currentPrice * (1 - stopLossDistance);\n      stopLoss = supportStop > 0 && supportStop < currentPrice ? \n        Math.max(supportStop, percentageStop) : percentageStop;\n    } else {\n      // For short positions, use resistance level or percentage-based stop\n      const resistanceStop = h4Data.technicalIndicators.resistance;\n      const percentageStop = currentPrice * (1 + stopLossDistance);\n      stopLoss = resistanceStop > currentPrice ? \n        Math.min(resistanceStop, percentageStop) : percentageStop;\n    }\n    \n    // Calculate multiple take profit levels\n    const takeProfit: number[] = [];\n    const tpDistances = [0.02, 0.04, 0.06]; // 2%, 4%, 6%\n    \n    for (const distance of tpDistances) {\n      if (isLong) {\n        takeProfit.push(currentPrice * (1 + distance));\n      } else {\n        takeProfit.push(currentPrice * (1 - distance));\n      }\n    }\n    \n    return { stopLoss, takeProfit };\n  }\n\n  /**\n   * Determine overall risk level\n   */\n  private determineRiskLevel(analysis: MultiTimeframeAnalysis): 'LOW' | 'MEDIUM' | 'HIGH' | 'EXTREME' {\n    const factors = {\n      volatility: analysis.riskAssessment.volatility,\n      reversalProb: analysis.riskAssessment.reversalProbability,\n      trendStability: analysis.riskAssessment.trendStability,\n      timeframeAlignment: analysis.consensus.timeframeAlignment\n    };\n    \n    // Calculate risk score\n    let riskScore = 0;\n    \n    // Volatility risk\n    switch (factors.volatility) {\n      case 'LOW': riskScore += 1; break;\n      case 'MEDIUM': riskScore += 2; break;\n      case 'HIGH': riskScore += 3; break;\n      case 'EXTREME': riskScore += 4; break;\n    }\n    \n    // Reversal probability risk\n    if (factors.reversalProb > 0.7) riskScore += 2;\n    else if (factors.reversalProb > 0.5) riskScore += 1;\n    \n    // Trend stability risk (inverted - low stability = high risk)\n    if (factors.trendStability < 0.3) riskScore += 2;\n    else if (factors.trendStability < 0.5) riskScore += 1;\n    \n    // Timeframe alignment risk (inverted)\n    if (factors.timeframeAlignment < 0.5) riskScore += 2;\n    else if (factors.timeframeAlignment < 0.7) riskScore += 1;\n    \n    // Determine risk level\n    if (riskScore <= 2) return 'LOW';\n    if (riskScore <= 4) return 'MEDIUM';\n    if (riskScore <= 6) return 'HIGH';\n    return 'EXTREME';\n  }\n\n  /**\n   * Generate entry conditions\n   */\n  private generateEntryConditions(analysis: MultiTimeframeAnalysis): string[] {\n    const conditions = [];\n    \n    // Timeframe alignment\n    conditions.push(`${(analysis.consensus.timeframeAlignment * 100).toFixed(1)}% timeframe alignment`);\n    \n    // Confidence level\n    conditions.push(`${(analysis.consensus.confidence * 100).toFixed(1)}% AI confidence`);\n    \n    // Technical conditions\n    const h1Data = analysis.timeframes['1h'];\n    if (h1Data.trend.direction !== 'NEUTRAL') {\n      conditions.push(`${h1Data.trend.direction.toLowerCase()} trend on 1H (${h1Data.trend.strength.toFixed(1)}% strength)`);\n    }\n    \n    // RSI conditions\n    if (h1Data.technicalIndicators.rsi < 30) {\n      conditions.push('RSI oversold on 1H');\n    } else if (h1Data.technicalIndicators.rsi > 70) {\n      conditions.push('RSI overbought on 1H');\n    }\n    \n    return conditions;\n  }\n\n  /**\n   * Generate exit conditions\n   */\n  private generateExitConditions(analysis: MultiTimeframeAnalysis): string[] {\n    const conditions = [];\n    \n    // Stop loss conditions\n    conditions.push(`Stop loss at ${analysis.riskAssessment.volatility.toLowerCase()} volatility level`);\n    \n    // Take profit conditions\n    conditions.push('Multiple take profit levels (2%, 4%, 6%)');\n    \n    // Reversal conditions\n    if (analysis.riskAssessment.reversalProbability > 0.6) {\n      conditions.push(`High reversal probability (${(analysis.riskAssessment.reversalProbability * 100).toFixed(1)}%)`);\n    }\n    \n    return conditions;\n  }\n\n  /**\n   * Identify risk factors\n   */\n  private identifyRiskFactors(analysis: MultiTimeframeAnalysis): string[] {\n    const risks = [];\n    \n    // Volatility risk\n    if (analysis.riskAssessment.volatility === 'HIGH' || analysis.riskAssessment.volatility === 'EXTREME') {\n      risks.push(`${analysis.riskAssessment.volatility.toLowerCase()} market volatility`);\n    }\n    \n    // Reversal risk\n    if (analysis.riskAssessment.reversalProbability > 0.6) {\n      risks.push(`High trend reversal probability (${(analysis.riskAssessment.reversalProbability * 100).toFixed(1)}%)`);\n    }\n    \n    // Trend stability risk\n    if (analysis.riskAssessment.trendStability < 0.5) {\n      risks.push(`Low trend stability (${(analysis.riskAssessment.trendStability * 100).toFixed(1)}%)`);\n    }\n    \n    // Timeframe disagreement\n    if (analysis.consensus.timeframeAlignment < 0.7) {\n      risks.push(`Timeframe disagreement (${(analysis.consensus.timeframeAlignment * 100).toFixed(1)}% alignment)`);\n    }\n    \n    return risks;\n  }\n\n  /**\n   * Generate detailed reasoning\n   */\n  private generateDetailedReasoning(analysis: MultiTimeframeAnalysis): string {\n    const parts = [];\n    \n    // Consensus summary\n    parts.push(`Multi-timeframe consensus: ${analysis.consensus.signal}`);\n    parts.push(`Confidence: ${(analysis.consensus.confidence * 100).toFixed(1)}%`);\n    parts.push(`Timeframe alignment: ${(analysis.consensus.timeframeAlignment * 100).toFixed(1)}%`);\n    \n    // Key timeframe insights\n    const h4 = analysis.timeframes['4h'];\n    const h1 = analysis.timeframes['1h'];\n    \n    parts.push(`4H trend: ${h4.trend.direction} (${h4.trend.strength.toFixed(1)}% strength)`);\n    parts.push(`1H signal: ${h1.signals.entry} (${(h1.signals.confidence * 100).toFixed(1)}% confidence)`);\n    \n    // Risk assessment\n    parts.push(`Risk level: ${analysis.riskAssessment.volatility} volatility`);\n    parts.push(`Recommended position size: ${(analysis.riskAssessment.recommendedPositionSize * 100).toFixed(1)}%`);\n    \n    return parts.join('. ');\n  }\n\n  /**\n   * Create hold signal\n   */\n  private createHoldSignal(symbol: string, analysis: MultiTimeframeAnalysis, reason: string): StrategySignal {\n    return {\n      symbol,\n      action: 'HOLD',\n      confidence: 0.5,\n      reasoning: `HOLD: ${reason}`,\n      positionSize: 0,\n      leverage: 1,\n      stopLoss: 0,\n      takeProfit: [],\n      timeframeAlignment: analysis.consensus.timeframeAlignment,\n      riskLevel: 'HIGH',\n      metadata: {\n        multiTimeframeAnalysis: analysis,\n        entryConditions: [],\n        exitConditions: [],\n        riskFactors: [reason]\n      }\n    };\n  }\n\n  /**\n   * Get current price from analysis\n   */\n  private getCurrentPrice(analysis: MultiTimeframeAnalysis): number {\n    const oneMinData = analysis.timeframes['1m'].ohlcv;\n    return oneMinData.length > 0 ? oneMinData[oneMinData.length - 1].close : 0;\n  }\n\n  /**\n   * Update strategy configuration\n   */\n  updateConfig(newConfig: Partial<typeof this.config>): void {\n    this.config = { ...this.config, ...newConfig };\n    console.log('üìä Multi-timeframe strategy configuration updated:', this.config);\n  }\n\n  /**\n   * Get current configuration\n   */\n  getConfig(): typeof this.config {\n    return { ...this.config };\n  }\n}